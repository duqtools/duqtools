#!/bin/bash
HELP_STR="
Asynchronous Iteration
----------------------

Iterate through a sequence matching a given pattern within the specified range
running all iterations asynchronously

Usage:

    async_iter CMD_PATTERN RANGE_STR LABEL [STDOUT_FILE STDERR_FILE]

Input:

    CMD_PATTERN                 = command pattern for iteration. Uses the symbol %I
                                  to represent the iterator location, e.g.
                                  'cd test_%I; ./run_model_%I; cd -'

    RANGE_STR                   = range specification bash string, e.g. {1..10}

    LABEL                       = specify identifier for the iteration (for easier debugging)
                                  e.g. 'ITER_%I'
    STDOUT_FILE                 = direct stdout to a specified file
    STDERR_FILE                 = direct stderr to a specified file
"

set -e

if [ -z "$1" ]; then
    echo "$HELP_STR"
    exit 0
fi

if [ "$#" -ne 3 ] && [ "$#" -ne 5 ]; then
    echo "Expected 3 or 5 input arguments for 'async_iter' but got $#"
    exit 1
fi

CMD_PATTERN=$1
RANGE_STR=$2
LABEL=$3
STDOUT_FILE=$4
STDERR_FILE=$5

declare -a PROCESS_PIDS

for i in $(eval echo $RANGE_STR);
do
    ERR_MSG="Async Iter: Iteration '${LABEL//%I/$i}' Failed."
    echo "Async Iter: Starting iteration '${LABEL//%I/$i}'"
    if [ ! -z "$STDOUT_FILE" ] && [ ! -z "$STDERR_FILE" ]; then
        (eval "${CMD_PATTERN//%I/$i}" || (echo "$ERR_MSG"; exit 1)) >> /dev/stderr 2>>$STDERR_FILE 1>>$STDOUT_FILE &
        PROCESS_PIDS+=($!)
    else
        eval "${CMD_PATTERN//%I/$i}" || (echo $ERR_MSG; exit 1) &
        PROCESS_PIDS+=($!)
    fi
done

for pid in "${PROCESS_PIDS[@]}"; do
    wait "$pid"
done
